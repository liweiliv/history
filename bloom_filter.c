/*
 * bloom_filter.c
 *
 *  Created on: 2016年12月8日
 *      Author: liwei
 *      继承自leveldb
 */

// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.

#include "hash.h"
#include "bloom_filter.h"
static  uint32_t BloomHash(const char * key, size_t size)
{
    return c_hash(key, size, 0xbc9f1d34);
}

static inline void resize_bloom_filter(bloom_filter * filter, size_t size)
{
    if (filter->size + size < filter->real_size)
    {
        filter->size += size;
    }
    else
    {
        char * tmp_buf = (char*) malloc(filter->real_size = (filter->size * 2
                + size));
        memcpy(tmp_buf, filter->bits, filter->size);
        memset(tmp_buf + filter->size, 0, filter->size + size);
        filter->size += size;
        free(filter->bits);
        filter->bits = tmp_buf;
    }
    filter->bits[filter->size - 1] = filter->k;
}
void init_bloom_filter(bloom_filter * filter, int bits_per_key, size_t key_size)
{
    filter->k = (size_t) (bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (filter->k < 1)
        filter->k = 1;
    if (filter->k > 30)
        filter->k = 30;
    filter->bits_per_key = bits_per_key;
    filter->bits = (char*) malloc(filter->real_size = 1024);
    memset(filter->bits, 0, filter->real_size);
    filter->size = 0;

    size_t bits = key_size * bits_per_key;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64)
        bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    resize_bloom_filter(filter, filter->size + bytes);
}

void insertFilter(bloom_filter * filter, const char * key, size_t size)
{
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = filter->bits_per_key;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64)
        bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    char* array = filter->bits;
    // Use double-hashing to generate a sequence of hash values.
    // See analysis in [Kirsch,Mitzenmacher 2006].
    uint32_t h = BloomHash(key, size);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < filter->k; j++)
    {
        const uint32_t bitpos = h % bits;
        array[bitpos / 8] |= (1 << (bitpos % 8));
        h += delta;
    }
}
void insertNumFilter(bloom_filter * filter, int64_t key)
{
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = filter->bits_per_key;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64)
        bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    char* array = filter->bits;
    // Use double-hashing to generate a sequence of hash values.
    // See analysis in [Kirsch,Mitzenmacher 2006].
    uint32_t h = hash64_32shift(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < filter->k; j++)
    {
        const uint32_t bitpos = h % bits;
        array[bitpos / 8] |= (1 << (bitpos % 8));
        h += delta;
    }
}
int KeyMayMatch(const bloom_filter * filter, const char * key, size_t size)
{
    const size_t len = filter->size;
    if (len < 2)
        return -1;

    const char* array = filter->bits;
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len - 1];
    if (k > 30)
    {
        // Reserved for potentially new encodings for short bloom filters.
        // Consider it a match.
        return 0;
    }

    uint32_t h = BloomHash(key, size);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++)
    {
        const uint32_t bitpos = h % bits;
        if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0)
            return -1;
        h += delta;
    }
    return 0;
}
int KeyNumMayMatch(const bloom_filter * filter, int64_t key)
{
    const size_t len = filter->size;
    if (len < 2)
        return -1;

    const char* array = filter->bits;
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len - 1];
    if (k > 30)
    {
        // Reserved for potentially new encodings for short bloom filters.
        // Consider it a match.
        return 0;
    }

    uint32_t h = hash64_32shift(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++)
    {
        const uint32_t bitpos = h % bits;
        if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0)
            return -1;
        h += delta;
    }
    return 0;
}
